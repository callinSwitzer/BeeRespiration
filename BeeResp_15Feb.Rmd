---
title: "BeeResp_15Feb"
author: "Callin Switzer"
date: "February 15, 2017; Update 1 March 2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir ='/Users/callinswitzer/Documents/GitRepos/BeeRespiration/')
```

### Summary:
Two avenues of analysis:

1.  First we see how $\Delta$load affects $\Delta$ArcLength^2 and $\Delta$frequency^2, accounting for bee size and treatment order
2.  We check to see how $\Delta$frequency and $\Delta$ArcLength are associated with $\Delta$MetabolicRate, while accounting for $\Delta$load

### Measured variables:

- Bee ID: Name given to an invididual (subscript in equations)
- Order: This is the trial number per individual, either 1 or 2
- Treatment: Either light or heavy- H is with both nectar and external load, L is just nectar load (subscript in equations)
- MStarved: The empty mass of the bee after being starved for days, until it no longer buzzes when prodded in grams
- M2: Total mass of the bee and load at beginning of trial in grams
- MF: The mass of the bee and load at end of trial in grams
- ITspan=intertegular span in m
- S=area of both forewings in $m^2$
- MetR= Metabolic rate in mL $CO_2$ $hr^{-1}$
- Freq= wing beat frequency in Hz
- Amp= stroke amplitude of forewing in degrees
- L= length of forewing from wing base to tip in m
 
 
### Calculated variables:
- MT: Mtrial, total mass, =(M2+MF)/2 = the average mass of the course of the trial
- Load= Mtrial- Mstarved
- Perload=  Percent load, %load (Load/Mstarved)x100
- ArcL= (.75 $\cdotp$ wlength) (Amp ($\pi$/180)) 	pi/180 converts to radians
- U= wing velocity, arcL$\cdotp$ frq $\cdotp$ 2   (the 2 comes from the fact that frequency consists of both an up and down stroke, vel=∆x/∆t, ∆x=arclength, ∆t=1/(freg $\cdotp$ 2)
- Freqsq=$Freq^2$
- ArcLsq=$ArcL^2$
- Force=$U^2 \cdotp S$

</pre>


## Install packages and read data

```{r, message=FALSE, warning=FALSE}
ipak <- function(pkg){
     new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
     if(length(new.pkg)) install.packages(new.pkg, dependencies = TRUE)
     sapply(pkg, require, character.only = TRUE)
}

packages <- c('ggplot2', 'car', 'lme4', 'gsheet', "MASS",'reshape2', 
              'influence.ME', 'sjPlot', "effects", 'visreg')
ipak(packages)

# read in data -- google sheet called "Final Bee Resp Data"
url = 'https://docs.google.com/spreadsheets/d/1wT-QxSJJElhhJcIXlg2hDpFKHbLyFGuqNNj2iYvA8Vo/edit?usp=sharing'
bdta <- data.frame(gsheet2tbl(url))
summary(bdta)
```


# Calculate variables
```{r}
bdta <- within(bdta, {
     MT = (M2 + MF)/2
     load = MT - Mstarved
     perLoad = load / Mstarved * 100
     arcL = (0.75 * L) * (amp * (pi / 180))
     U = arcL * freq * 2
     freq2 = freq^2
     arcL2 = arcL^2
     frce = U^2 * S
     
     # convert to factor variables
     order = as.factor(as.character(order))
     Treatment = as.factor(as.character(Treatment))
     BeeID = as.factor(as.character(BeeID))
})
```


### Create a new dataframe that calculates the changes for each bee
```{r}
# convert from long to wide
newDF <- data.frame()
colsTocalc = c("order", "M2", "MF", "MetR", "freq", "amp", "load", "MT", "perLoad", "frce", "arcL2", "freq2", "U", "arcL")
for(varb in colsTocalc){
     data_wide <- dcast(bdta, BeeID + Mstarved + S + Itspan + L ~ 
                             Treatment, value.var=c(varb))
     colnames(data_wide)[6:7] = paste(varb, colnames(data_wide)[6:7], sep = "_")
     if(varb == colsTocalc[1]){
       newDF <- data_wide   
     }
     else newDF <- merge(newDF, data_wide, all.y = TRUE)    
}

head(newDF)
```


### Calculate $\Delta$ variables

```{r}

newDF <- within(newDF, {
     deltaPercLoad = perLoad_H - perLoad_L
     avgPercLoad = (perLoad_H + perLoad_L) / 2
     deltaMetR = MetR_H - MetR_L
     deltaFrq2 = freq2_H - freq2_L
     deltaArcL = arcL_H - arcL_L
     deltaArcL2 = arcL2_H - arcL2_L
     deltaFreq2Perc = deltaFrq2 / deltaPercLoad
     deltaLoad = scale(load_H - load_L, center = TRUE, scale = FALSE)
     dLoad_nonCent = load_H - load_L
     deltaLoad2 <- deltaLoad^2
})


plot(newDF$deltaArcL2 ~ newDF$deltaFrq2)

# compare with Susie's calculations



b2 <- read.csv("~/Desktop/b2.csv")
b2 <- b2[!is.na(b2$deltaperload), ]
b2 <- b2[order(b2$BeeID, b2$Treatment), ]

plot(b2$AverageperLoad, newDF$avgPercLoad)
abline(0,1)

plot(b2$deltaload, newDF$deltaLoad)
abline(0,1)
```



### Use PCA to combine bee sizes into a single predictor

```{r}
# principle components
aa = prcomp(newDF[, c("Mstarved", "Itspan", "S", "L")], center = TRUE, scale = TRUE)
summary(aa) # 1st pc explains ~95% of the variance in the three measurements of size

biplot(aa) # shows that all three size measurement are correlated

# note, I changed the signs of the predictions so that higher PC1 values 
# correspond to bigger bees
p1 = -predict(aa)[,1] 

# add PC1 scores to dataset
newDF$size_pc1 = p1
newDF$size_pc1_2 = newDF$size_pc1^2

# show scatterplot matrix to see correlations among size predictors
car::scatterplotMatrix(newDF[, c("Mstarved", "Itspan", "S",  "L",  "size_pc1")])
```

### 1.  First we see how $\Delta$load affects $\Delta$ArcLength accounting for bee size and treatment order

This is the model selection procedure that was used: 
1. Fit a large model with all two-way interactions and squared terms
2. Remove non-significant predictors, starting with interactions, squared terms, and then main effects

```{r}

# reformat order so that it is more interpretable
library(plyr)
newDF$order_1 <- mapvalues(newDF$order_H, from = c(2, 1), to = c("loadedSecond", "loadedFirst"))

# fit full model
m1 <- lm(deltaArcL2 ~  (deltaLoad +  size_pc1 + order_1)^2  + 
              size_pc1_2  + deltaLoad2, data = newDF)
summary(m1)


m2 <- update(m1, .~. - deltaLoad:size_pc1)
anova(m1, m2)

summary(m2)
m3 <- update(m2, .~. - deltaLoad:order_1)

anova(m2, m3)
summary(m3)

m4 <- update(m3, .~. - size_pc1:order_1)
anova(m3, m4) 
summary(m4)


m5 <- update(m4, .~. - deltaLoad2)
anova(m4,m5) 

summary(m5)

m6 <- update(m5, .~.  - size_pc1_2)
anova(m6, m5) 
summary(m6)

m7 <- update(m6, .~. - order_1)
anova(m7, m6)
summary(m7)


anova(m7, update(m7, .~. - deltaLoad)) # p-value for delta load
anova(m7, update(m7, .~. - size_pc1)) # p-value for size

summary(m7)

# refit model with non-centered version of deltaLoad
# this model will have a different intercept, but same p-values for slopes
summary(update(m7, .~. - deltaLoad + dLoad_nonCent)) # final model for paper
```


### model diagnostics

```{r}

par(mfrow = c(2,2))
plot(m7, which = 1:4) # no glaring violations, though there are a few fairly influential observations
par(mfrow = c(1,1))

car::vif(m7) 
```

### Model visualization

```{r}
summary(m7)


# calculate partial residuals for deltaLoad
# these are the  residuals, minus the effect of detlaLoad
y <- residuals(m7, type = 'partial')[, "deltaLoad"]

# plot partial residuals with base R plotting
plot(x = newDF$deltaLoad, y = y)

# double check to make sure the slope for partial residual plots are the 
# same as in the original regression
summary(lm(y ~ newDF$dLoad_nonCent)) 

# this is what the raw data look like
plot(x = newDF$deltaLoad, y = newDF$deltaFrq2)


# this package plots the partial residuals
crPlot(m7, variable = "deltaLoad")


# plot with ggplot2
theme_set(theme_classic()) 

# plot raw data w/ ggplot
ggplot(newDF, aes(x= size_pc1, y = deltaArcL, color = deltaLoad)) + 
     geom_point()

ggplot(newDF, aes(x= deltaLoad, y = deltaArcL, color = size_pc1)) + 
     geom_point()



# y axis isn't easily interpretable
ggplot(newDF, aes(x= dLoad_nonCent, y = y)) + 
     geom_point() + 
     labs(x = "delta load", y = "partial residuals for delta load \n i.e. delta load effect on arcL^2 \n while subtracing affect of bee size") + 
     stat_smooth(method = 'lm', se = FALSE)

```

<hr>

### Takeaways from model 1:
1.  A higher deltaload (i.e. a relatively larger "high" load) causes bees to have a larger change in arclength squared.  Another way to say this is that increasing the change in load by 1 gram causes an increase in the change in arclength^2 by 0.002059 degrees.
2. The larger the bee, the lower the change in arcLength^2 (association, rather than causation), while holding the change in load constant. 
3. We do not have enough evidence to notice any non-linear relationships in this model.

<hr>


### See how $\Delta$load affects  $\Delta$frequency, accounting for bee size and treatment order


```{r}
# fit full model
m1 <- lm(deltaFrq2 ~  (deltaLoad +  size_pc1 + order_1)^2  + 
              size_pc1_2  + deltaLoad2, data = newDF)
summary(m1)
car::vif(m1) # some serious multicollinearity

m2 <- update(m1, .~. - size_pc1:order_1)
anova(m1, m2)

summary(m2)
m3 <- update(m2, .~. - deltaLoad:size_pc1)

anova(m2, m3)
summary(m3)

m4 <- update(m3, .~. - deltaLoad:order_1)
anova(m3, m4) 
summary(m4)

m5 <- update(m4, .~. - size_pc1_2)
anova(m4,m5) 

summary(m5)

m6 <- update(m5, .~.  - deltaLoad2)
anova(m6, m5) 
summary(m6)

m7 <- update(m6, .~. - size_pc1)
anova(m7, m6) # p-values for size
m8 <- update(m6, .~. - deltaLoad)
anova(m6, m8) # p-value for deltaLoad
m9 <- update(m6, .~. - order_1)
anova(m6, m9) # p-value for order

# refit final model with non-centered deltaLoad
m10 <- update(m6, .~. - deltaLoad + dLoad_nonCent)
summary(m10) # final model for paper
```


### model diagnostics

```{r}

par(mfrow = c(2,2))
plot(m10, which = 1:4) # no glaring violations
par(mfrow = c(1,1))

car::vif(m10) # vif is a little high
```

### model visualization
```{r}
# calculate partial residuals for deltaLoad
# these are the  residuals, minus the effect of detlaLoad
y <- residuals(m10, type = 'partial')[, "dLoad_nonCent"]

# plot partial residuals with base R plotting
plot(x = newDF$dLoad_nonCent, y = y)

# double check to make sure the slope for partial residual plots are the 
# same as in the original regression
summary(lm(y ~ newDF$dLoad_nonCent)) 

# this is what the raw data look like
plot(x = newDF$dLoad_nonCent, y = newDF$deltaFrq2)


# this package plots the partial residuals
crPlot(m10, variable = "dLoad_nonCent")


# plot with ggplot2
# plot raw data w/ ggplot
ggplot(newDF, aes(x= size_pc1, y = deltaFrq2, color = deltaLoad, shape = order_1)) + 
     geom_point()

ggplot(newDF, aes(x= deltaLoad, y = deltaFrq2, color = size_pc1, shape = order_1)) + 
     geom_point()



# y axis isn't easily interpretable
ggplot(newDF, aes(x= dLoad_nonCent, y = y)) + 
     geom_point() + 
     labs(x = "delta load", y = "partial residuals for delta load \n i.e. delta load effect on freq^2 \n while subtracing affect of bee size and order") + 
     stat_smooth(method = 'lm', se = FALSE)


# partial residuals for order

y <- residuals(m10, type = 'partial')[, "order_1"]

ggplot(newDF, aes(x= order_1, y = y)) + 
     geom_boxplot() + 
     labs(x = "order", y = "partial residuals for order \n i.e. order effect on freq^2 \n while subtracing affect of bee size and load") + 
     stat_smooth(method = 'lm', se = FALSE)

# holding bee size and delta load constant, if a bee was loaded second, (confusing, huh?) then it would have a much lower freq^2 than if it was loaded first

summary(m10)
```



<hr>
### Takeaways from model 2:
1. Order, size, and deltaLoad are associated with a change in frequency^2.  We find no evidence of non-linear relationships or interactions.
2. Holding size and order constant, we find that a larger deltaLoad causes a decrease in deltaFrequency^2
3. Holding other variables constant, an increase in bee size is associated with a larger deltaFrequency^2.
4. Holding other variables constant, if the bee was loaded second, then they had a lower deltaFrequency^2 than if they were loaded first. 

```{r}
# make some predictions
predDF <- data.frame(size_pc1 = 0, order_1 = c("loadedSecond", "loadedFirst"), dLoad_nonCent = mean(newDF$dLoad_nonCent))

predDF$pred_deltaF2 <- predict(m10, predDF)

predDF
```

<hr>

### 2.  We check to see how $\Delta$frequency and $\Delta$ArcLength are associated with $\Delta$MetabolicRate, while accounting for $\Delta$load

```{r}
mm1 <- lm(deltaMetR ~ deltaFrq2 + deltaArcL2 + deltaLoad + size_pc1 + deltaLoad2, data = newDF)
car::vif(mm1)

summary(mm1)

mm2 <- update(mm1, .~. - size_pc1)
anova(mm1, mm2)
summary(mm2)

mm3 <- update(mm2, .~. - deltaArcL2)
anova(mm3, mm2)
summary(mm3)

mm4 <- update(mm3, .~. - deltaLoad2)
anova(mm3, mm4)
summary(mm4)

mm5 <- update(mm4, .~. - deltaLoad) 
anova(mm5, mm4) # p-value for load

mm6 <- update(mm4, .~. - deltaFrq2)
anova(mm4, mm6) # p-value for deltafrq2

# refit model with non-centered load
mm7 <- update(mm4, .~. - deltaLoad + dLoad_nonCent)

summary(mm7) # final model for paper
```

### model diagnostics

```{r}

car::vif(mm7)

par(mfrow = c(2,2))
plot(mm7, which = 1:4) # no glaring violations
par(mfrow = c(1,1))

```


### model visualization

```{r}

# calculate partial residuals for deltaLoad
# these are the  residuals, minus the effect of detlaLoad
y <- residuals(mm7, type = 'partial')[, "dLoad_nonCent"]

# plot partial residuals with base R plotting
plot(x = newDF$dLoad_nonCent, y = y)

# double check to make sure the slope for partial residual plots are the 
# same as in the original regression
summary(lm(y ~ newDF$dLoad_nonCent)) 
summary(mm7)

# this is what the raw data look like
plot(x = newDF$dLoad_nonCent, y = newDF$deltaMetR)


# this package plots the partial residuals
crPlot(mm7, variable = "dLoad_nonCent")
crPlot(mm7, variable = "deltaFrq2")
summary(mm7) # final model for paper

```

<hr>
### Takeaways for model 3:
1. Deltafreq^2 and deltaLoad are both associated with deltaMetR.
2. Holding deltafreq constant (not necessarily at 0), an increase in deltaload is associated with an increase in deltametabolicRate
3. Holding deltaLoad constant (not holding load constant, and again, not holding deltaload necessarily at 0), an increase in deltaFreq^2 is associated with an increase in deltaMetabolic rate. 
4. We found no evidence to suggest that a change in deltaArcL^2 is associated with deltametabolicRate. (this is not saying that arcLength doesn't affect metabolic rate).

<hr>

Refref:
Do regression for Average percent loading vs. delta metabolic rate / 1% load etc. It's the last page of the document Susie sent (3 different response variables).

Covariates: avg % load, order, bee size.





# Session Info
```{r}
sessionInfo()

Sys.time()

```